<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="Prawar Poudel" name="author"/>
  <meta content="Vector Databases, AI, Machine Learning, NLP, GPT" name="keywords"/>
  <meta content="" name="description"/>
  <link href="../css/main.css" rel="stylesheet" type="text/css"/>
  <title>
   Unsupervised Learning
  </title>
 </head>
 <body>
  <!-- this one is on the top for navigation -->
  <div class="navbar">
   <a href="../index.html">
    Home
   </a>
   <a href="../about.html">
    About
   </a>
   <a href="https://www.linkedin.com/in/prawarpoudel/">
    LinkedIn
   </a>
   <a href="https://scholar.google.com/citations?user=qa8tuSIAAAAJ&amp;hl=en">
    Google Scholar
   </a>
  </div>
  <!-- following is the sidebar -->
  <div class="sidebar">
   <a class="" href="https://prawarpoudel.github.io/about">
    About
   </a>
   <a class="listt" href="../pages/ai_topics.html">
    AI Topics
   </a>
   <a class="listt" href="../pages/ml_basics.html">
    ML Topics
   </a>
   <a class="listt" href="../pages/datascience_topics.html">
    Data Science Topics
   </a>
   <a class="listt" href="../pages/programming_topics.html">
    Programming Topics
   </a>
   <a class="listt" href="../pages/systemdesign.html">
    System Design Topics
   </a>
   <a class="listt" href="../pages/kube_topics.html">
    Kubernetes
   </a>
   <a class="listt" href="../pages/regex_py.html">
    Regex in python
   </a>
   <a class="listt" href="../pages/alerting.html">
    Ex-Google SRE on Alerting
   </a>
   <a class="listt" href="../pages/coding_topics.html">
    Various Coding Exercises
   </a>
  </div>
  <div class="content">
   <h1>
    Unsupervised Learning
   </h1>
   <p>
    <ul>
     <li>
      Datapoints do not have any outcomes, or target is unknown.
     </li>
     <li>
      We are interested in the structure of the data or the patterns within the data.
     </li>
     <li>
      Types:
      <ul>
       <li>
        <a href="unsupervised_learning_clustering.html">
         <b>
          Clustering:
         </b>
        </a>
        Algorithm like:
        <ul>
         <li>
          K-Means
         </li>
         <li>
          Hierarchical Agglomerative Clustering
         </li>
         <li>
          DBSCAN
         </li>
         <li>
          Mean shift
         </li>
        </ul>
       </li>
       <li>
        <a href="unsupervised_learning_dimsreduction.html">
         <b>
          Dimensionality Reduction:
         </b>
        </a>
        Algorithm like:
        <ul>
         <li>
          PCA
         </li>
         <li>
          Non-negative matrix factorization
         </li>
         <li>
          They are important because of the
          <mark>
           curse of dimensionality
          </mark>
          .
         </li>
         <li>
          .. which means that as no of features increases performance gets worse, and cost or the number of training examples required increases.
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      Many use cases like:
      <ul>
       <li>
        Classification
       </li>
       <li>
        Anomaly Detection
       </li>
       <li>
        Customer Segmentation
       </li>
       <li>
        Improve Supervised Learning
       </li>
      </ul>
     </li>
    </ul>
   </p>
   <hr/>
   <h2>
    Timeseries Analysis
   </h2>
   <p>
    <ul>
     <li>
      used for forecasting
     </li>
     <li>
      data correlated over time; and are often non-stationary. Thus, very hard to model.
     </li>
     <li>
      needs a lot of data
     </li>
     <li>
      propagation of forecast error from one period to another
     </li>
     <li>
      Time Series: sequence of data points that are organized in time. Data is equally spaced points in time. Irregular data is not considered Time Series.
     </li>
     <li>
      standard measures like
      <i>
       forecast miss
      </i>
      and
      <i>
       error rates by horizon
      </i>
      can be misleading
     </li>
     <li>
      <ul>
       <li>
        <b>
         Univariate
        </b>
        : Single data series (could be continuous, binary or categorical); can be multiple unrelated or related series; could be conditional series
       </li>
       <li>
        <b>
         Panel/Multivariate
        </b>
        : Multiple related series with identifying groups like customer types, department etc; may be used for joint estimation across series
       </li>
      </ul>
     </li>
     <li>
      some important functions for plotting are: plot_acf(), plot_pacf(), month_plot(), quarter_plot()
     </li>
    </ul>
   </p>
   <hr/>
   <h4>
    Autocorrelation Plot
   </h4>
   <p>
    TODO
   </p>
   <p>
    <ul>
     <li>
      autocorrelation means todays data is highly dependent on some past value
     </li>
     <li>
      time interval between correlated values is called
      <mark>
       lag
      </mark>
     </li>
     <li>
      a simple way to remove autocorrelation in some degree is to perform subtraction with the lagged data, ie.,
      <mark>
       data (t) = data_old(t) - data_old(t-delta)
      </mark>
     </li>
    </ul>
   </p>
   <hr/>
   <h4>
    Decomposing Time series
   </h4>
   <p>
    <ul>
     <li>
      Decomposition allows to remove the deterministic components of data, and make modeling easier.
     </li>
     <li>
      Trend: Long Term direction, Seasonality: Periodic Behavior, Residual: Irregular/random Fluctuations that is left after trend or seasonality is removed.
     </li>
     <li>
      Models perform better if we remove known sources of variation. For example, trend and seasonality.
     </li>
     <li>
      Types of decomposition:
      <ul>
       <li>
        Additive decomposition:
       </li>
       <li>
        Multiplicative decomposition:
       </li>
       <li>
        Pseudo-additive: combination of both above, for example, we expect a multplicative model, but there could be zero in the value.
       </li>
      </ul>
     </li>
     <li>
      How to decompose?
      <ul>
       <li>
        Single, double or triple exponential smoothing
       </li>
       <li>
        Locally Estimated Scatterplot Smoothing (LOESS)
       </li>
       <li>
        Frequency based methods: uses spectral analysis
       </li>
      </ul>
     </li>
    </ul>
   </p>
   <p>
    in python use,
    <mark>
     from statsmodels.tsa.seasonal import seasonal_decompose
    </mark>
    . The output gives out all the three components, trend, seasonal and residuals. We can specify
    additive or multiplicative as the model to be used. The
    <mark>
     freq
    </mark>
    or the
    <mark>
     period
    </mark>
    argument is an important hyperparameter.
   </p>
   <p>
    <b>
     Stationarity
    </b>
    <ul>
     <li>
      Stationary data means having same mean and variance over time. 4 key properties of a stationary series are:
      <ul>
       <li>
        constant mean
       </li>
       <li>
        constant variance
       </li>
       <li>
        constant autocorrelation structure
       </li>
       <li>
        no periodic component
       </li>
      </ul>
     </li>
     <li>
      non-stationary models are very hard to model. Approach to handle non-stationary model is as follows:
      <ul>
       <li>
        identify the source of non-stationary
       </li>
       <li>
        transform series to make it stationary
       </li>
       <li>
        build models with stationary series
       </li>
      </ul>
     </li>
     <li>
      <mark>
       Augmented-Dickey Fuller Test
      </mark>
      can be used to identify if a series is stationary or not. Other method is the visual method,to identify the 4 properties mentioned above.
     </li>
     <li>
      <p class="code-text">
       from statsmodels.tsa.stattools import adfuller

adf,pvalue,usedlag,nobs,critical_value,icbest = adfuller(data)
      </p>
      <p>
       p-value too small means its not stationary. ADF value can sometimes be misleading in concluding the stationarity of the series. This is true in variance fluctuating series (heteroscadicity series)
      </p>
     </li>
     <li>
      Sources of non-stationarity in time series data:
      <ul>
       <li>
        changes in trend and changes in variance (heteroscedasticity)
       </li>
       <li>
        dependence on recent observations (autocorrelation)
       </li>
       <li>
        seasonal patterns
       </li>
      </ul>
     </li>
     <li>
      To forecast time series data, we need to find if:
      <ul>
       <li>
        our data is non-stationary
       </li>
       <li>
        what causes non-stationarity in our data.
       </li>
       <li>
        can we transform our data into a stationary series that can be modeled
       </li>
      </ul>
     </li>
     <li>
      identifying non stationarity:
      <ul>
       <li>
        run sequence plots
       </li>
       <li>
        looking at summary stats: divide data into chunks and look at mean, variance
       </li>
       <li>
        histogram plots: stationary data is close to normal distribution
       </li>
       <li>
        statistical tests: like Augmented Dickey Fuller test; when p-value is less than 0.5, series in stationary
       </li>
       <li>
        best to use more than one technique above
       </li>
      </ul>
     </li>
     <li>
      <b>
       Common transformations to create stationary data from non-stationary data:
      </b>
      <ul>
       <li>
        remove trend and seasonality
       </li>
       <li>
        remove variances: squash the large values by appliying log transformation
       </li>
       <li>
        remove autocorrelation: subtract data with data (t-lag)
       </li>
      </ul>
     </li>
     <li>
      <b>
       Time series smoothing
      </b>
      <ul>
       <li>
        imporves the ability to forecast by reducing the impact of noise, improves forward looking forecast
       </li>
       <li>
        <b>
         Simple Average Smoothing
        </b>
       </li>
       <li>
        <b>
         Equally Weighted Moving Average
        </b>
       </li>
       <li>
        <b>
         Exponentially Weighted Moving Average
        </b>
       </li>
       <li>
        <b>
         Exponential Smooting
        </b>
        : apply exponential weights to the values that are in the window for moving average. The weight is applied such that recent values are given more weights. It is more sensitive to local changes.
       </li>
       <li>
        <b>
         Single Exponential Smoothing:
        </b>
        <p>
         <img src="../images/singleexponentialsmothing.png" width="40%"/>
        </p>
        It does not pick seasonality nor trend.
       </li>
       <li>
        <p class="code-text">
         from statsmodels.tsa.api import SimpleExpSmoothing

single = SimpleExpSmoothing(train).fit(optimized=True)
single_preds = single.forecast(10) # predict 10 future points
        </p>
       </li>
       <li>
        <b>
         Double Exponential Smooting:
        </b>
        has the ability to have trend. For this a second component is added.
        <p>
         <img src="../images/doubleexponentialsmoothing_1.png" width="40%"/>
         <br/>
         <img src="../images/doubleexponentialsmoothing_2.png" width="20%"/>
        </p>
        but fails to pick seasonality
       </li>
       <li>
        <p class="code-text">
         from statsmodels.tsa.api import Holt

double = Holt(train).fit(optimized=True)
double_preds = double.forecast(10) # predict 10 futurepoints
        </p>
       </li>
       <li>
        <b>
         Triple Exponential Smoothing:
        </b>
        has the ability to pick up seasonality by adding a third term. Here, L is the length of seasonality
        <p>
         <img src="../images/tripleseasonalsmoothing_1.png" width="40%"/>
        </p>
       </li>
       <li>
        <p class="code-text">
         from statsmodels.tsa.api import ExponentialSmoothing

triple = ExponentialSmoothing(train,
                                trend="additive",
                                seasonal="additive",
                                    seasonal_periods=13).fit(optimized=True)
triple_preds = triple.forecast(10)
        </p>
       </li>
      </ul>
     </li>
     <hr/>
     <li>
      <b>
       ARMA
      </b>
      : combines two models, Autoregressive (AR) models that anticipate series dependence on its own past values; And Moving Average (MA) models that anticipate series dependece on past forecast errorss.
      <ul>
       <li>
        The combination of AR and MA is called
        <mark>
         ARMA
        </mark>
        model, also called
        <mark>
         Box-Jenkins Approach.
        </mark>
       </li>
       <li>
        AR(p) is assumed to depend on last p values of the time series.Thus the forecast takes the form of a linear combination of the past p- vlaues
       </li>
       <li>
        MA(q) is assumed to depend on last q-values of the forecast error. Thus the current forecast is the linear combination of the past q- forecast errors.
       </li>
       <li>
        The overall forecast is the sum of both the AR and MA aspect discussed in two points above.
       </li>
       <li>
        ARMA assumes the model to be stationary, and the timeseries does not contain a seasonal component.
       </li>
      </ul>
     </li>
     <li>
      How to determine seasonality in a plot?
      <ul>
       <li>
        Autocorrelation plot:
        <ul>
         <li>
          summarizes total correlation between a variable and its past values.
         </li>
        </ul>
       </li>
       <li>
        Partial Autocorrelation plot:
        <ul>
         <li>
          also shows the dependence on past observations
         </li>
         <li>
          however it measures partial results, including all lags
         </li>
        </ul>
       </li>
       <li>
        Seasonal Subseries Plot
        <ul>
         <li>
          Shows seasonal average levels for each seasonal period
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      To determine p and q, following approaches can be taken:
      <ul>
       <li>
        To look at the autocorrelation or partial autocorrelation plots;
        <ul>
         <li>
          For p in AR(p): in the partial autocorrelation plot (PACF), add confidence intervals. And choose p such that the partial correclation is insignificant for p+1 and beyond.
         </li>
         <li>
          For q in MA(q): in the autocorrelation plot (AFC), add confidence intervals. Choose q such that autocorrelation is insignificant for q+1 and beyond
         </li>
         <li>
          Following shows which kinds of model to choose based on shape of ACF or PACF model:
          <p>
           <img src="../images/arma_whichtochoose.png" width="50%"/>
          </p>
         </li>
        </ul>
       </li>
       <li>
        To treat p and q as hyperparameter, and apploy grid search, cross validation etc
       </li>
      </ul>
     </li>
     <li>
      If a process depends on previous values of itself, it is an AR process; If a process depends on previous errors than it is an MA process.
     </li>
     <li>
      AR models with propogate dependency infinitely; whereas MA models do not propagate the shock infinitely
     </li>
     <li>
      AR process will exhibit exponential decay in ACF and a cut-off in PACF.
     </li>
     <li>
      MA process will exhibit exponential decay in PACF and a cut off in ACF.
     </li>
     <li>
      Following table shows this in a bit detail:
      <p>
       <img src="../images/ar_or_ma.png" width="80%"/>
      </p>
     </li>
     <li>
      To tune parameters of ARMA model, since it can be non-linear problem: Non-linear least squares and MLE are common approaches.
        But most software will do that for us.
     </li>
     <li>
      <p class="code-text">
       import statmodels.api as sm

model = sm.tsa.ARMA(sample_datam, (2,0)).fit(trend='nc',disp=0) #(2,0) means we want p=2, q=0

model.params # this will give out two values; will give out 1 value for p=1, q=0
      </p>
     </li>
     <li>
      For testing purpose, we can also generate data using following
      <p class="code-text">
       from statsmodels.tsa.arima_process import arma_generate_sample
      </p>
     </li>
     <li>
      Similarly, for MA modeling, the same code for AR as above can be used, but with q=1 or q=2.
     </li>
    </ul>
   </p>
   <h4>
    ARIMA and SARIMA
   </h4>
   <p>
    <ul>
     <li>
      To adapt the ARMA model to deal with integrated (ARIMA) and seasonal models (Seasonal ARIMA).
     </li>
     <li>
      <b>
       Integrated series
      </b>
      are a result of adding previous values together, like Stock Prices (integrated) and stock returns. Such integrated series can be 
            transformed into stationary by subtracting the previous value from each observation.
     </li>
     <li>
      ARIMA extends ARMA for integrated series. It has three components.
      <b>
       AR model
      </b>
      ,
      <b>
       Integrated component
      </b>
      and
      <b>
       MA model
      </b>
     </li>
     <li>
      ARIMA is denoted as (p,d,q), where p is the order of AR model, d is the number of times to the difference the data, and q is the order of MA model. All non-negative integers.
     </li>
     <li>
      Differencing nonstationary time series data one or more times can make it stationary. This gives the integrated component.
      <b>
       d
      </b>
      gives the number of times to perform a (t-1) difference on the data.
     </li>
     <li>
      SARIMA incorporates seasonal component. It is represented as (p,d,q)(P,D,Q), where uppercase items represent the metrics across a season. For the difference, for example if we are dealing with yearly data, we subtract with items of last year.
     </li>
     <li>
      Techniques for generating p, d, q, P, D, Q:
      <ul>
       <li>
        visual inspection; generate ACF, PACF plot.
       </li>
       <li>
        treat as hyperparameters and corss validate.
       </li>
       <li>
        examine information criteria (AIC, BIC) which penalize the number of parameters the model uses.
       </li>
       <li>
        Automated selection using some software is also available
       </li>
      </ul>
     </li>
     <li>
      Assumptions for ARIMA, SARIMA
      <ul>
       <li>
        time series in stationary;
       </li>
       <li>
        if non stationary, remove trend, seasonality, apply differencing
       </li>
       <li>
        the past is assumed to represent what will happen in future, in a probabilistic sense.
       </li>
      </ul>
     </li>
    </ul>
   </p>
   <p class="code-text">
    from statsmodels.tsa.statspace.sarimax import SARIMAX

srma = sm.tsa.statesace.SARIMAX(data[temp],
        order=(p,d,q),
        seasonal_order=(0,1,1,12),
        trend='c').fit()

srma.summary()

srm.predict(start=start_idx,end=end_idx) # predict values for given index range
   </p>
   <p>
    The AIC and BIc values printed from the
    <mark>
     summary()
    </mark>
    above should be as little as possible
   </p>
   <p>
    There are auto fit models that will try to find the best models and bit the data. For example, for ARIMA, there is
    <mark>
     auto_arima
    </mark>
    .
   </p>
   <hr/>
   <h3>
    Facebook prophet
   </h3>
   <p>
    It adds g(t), s(t), h(t). Its an additive model. g(t) models the non-periodic functions, s(t) models the seasonality and h(t) models the holidays.
    we would prefer historical data of at least a year preferrably to make a good prediction.
    <p class="code-text">
     from fbprophet import Prophet

model = Prophet()
#you make want to take a log of data before fit() to make the variance smaller
model.fit(my_data)

#let us make a prediction for a year, by supplying 365 (no of days)
#.. this will create an empty dataframe with just the dates
forecast_dates = model.make_future_dataframe(periods=365)
forecast = model.predict(future)
    </p>
    To work with holidays, for the train data, you must specify the holidays in a dataframe; and supply this df as argument when creating 
    Prophet object, for example,
    <mark>
     model=Prophet(holidays=holidays)
    </mark>
   </p>
   <p class="code-text">
    thanksgiving = pd.DataFrame({
    'holiday': 'thanksgiving',
    'ds': pd.to_datetime(['xxxx-xx-xx','xxxx-xx-xx']),
    'lower_window': 0,
    'upper_window': 1,
})
# Similarly, create more if you want to
holidays = pd.concat((thanksgiving,another_holiday))

model = Prophet(holidays=holidays)
forecast = model.fit(my_data).predict(forecast_dates)
   </p>
   <p>
    You can also add regressor using
    <mark>
     add_regressor
    </mark>
    , and do a cross validation using
    <mark>
     .cross_validation()
    </mark>
   </p>
   <hr/>
   <h3>
    Deep Learning
   </h3>
   <p>
    <ul>
     <li>
      Automatically able to capture complex patterns and characteristics of time series like trend, seasonality and complex autocorrelations.
     </li>
     <li>
      can simlulatneously model many related series, rather than just one.
     </li>
     <li>
      cons: often overfit
     </li>
     <li>
      cons: challenging to interpret, more like black box
     </li>
     <li>
      cons: computationally expensive
     </li>
    </ul>
   </p>
   <h4>
    RNN: Recurrent Neural Networks
   </h4>
   <p>
    <ul>
     <li>
      maps a sequence of inputs to predicted outputs. Most common format is
      <mark>
       many-to-one
      </mark>
      format, which maps
            many input sequence to one input value.
     </li>
     <li>
      Here, input sequence is fed to update or learn the hidden state. After the hidden state is learned, the model uses the hidden state can be 
            used to predict the output.
     </li>
     <li>
      Learns patterns, and seasonality.
     </li>
     <li>
      but has dependency over many time steps, and its a problem for RNNs to capture long term dependencies. Thus,
      <mark>
       LSTM
      </mark>
      is introduced.
     </li>
     <li>
      Following is basic of how RNNs work:
     </li>
     <li>
      <ul>
       <li>
        Three trainiable metrics: U, V and W.
       </li>
       <li>
        hidden states are represented as h(i)
       </li>
       <li>
        sigmoid is the activation function, fn(x) = e^x/(e^x + 1)
       </li>
       <li>
        Weight metrics are applied as linear transformation
       </li>
       <li>
        Hidden state is updated as
        <mark>
         h(i) = fn(U*t(i) + V*h(i-1))
        </mark>
        , and
        <mark>
         t(out) = W*h(out-1)
        </mark>
       </li>
      </ul>
     </li>
     <li>
      <b>
       LSTM
      </b>
      <ul>
       <li>
        LSTM take longer to train than RNNs, and are more prone to overfitting.
       </li>
       <li>
        For each state of time, there is a hidden state and a cell state that allows a long term memory.
       </li>
       <li>
        the network regulate information flow and memory storage; and they control how memory states are updated and information is passed forward.
       </li>
       <li>
        gating at each state; and some information might be forgotten if deemed not necessary.
       </li>
       <li>
        cons: slower to train because of slow backpropagation, and more prone to overfit. More parameters needed.
       </li>
       <li>
        When the sequence are too long, RNN may perform poorly so choose LSTM. But LSTMs are expensive computationally.
       </li>
      </ul>
     </li>
    </ul>
   </p>
   <p>
    Coding examples for RNN:
    <p class="code-text">
     import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, SimpleRNN, LSTM, Activation, Dropout

model = Sequential()
noofhiddenunits = 10 #could be any number
model.add(SimpleRNN(noofhiddenunits,input_shape=xxx))
model.add(Dense(1))

model.compile(loss='mean_squared_error',optimizer='adam')
model.fit(x_train,y_train, epochs=epoch_num, batch_size=64)

#to print the detail of the model
model.summary()
    </p>
    Similar is the code example for LSTM:
    <p class="code-text">
     import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, SimpleRNN, LSTM, Activation, Dropout

model = Sequential()
noofhiddenunits = 10 #could be any number
model.add(LSTM(noofhiddenunits,input_shape=xxx))
model.add(Dense(1))

model.compile(loss='mean_squared_error',optimizer='adam')
model.fit(x_train,y_train, epochs=epoch_num, batch_size=64)

#to print the detail of the model
model.summary()
    </p>
   </p>
   <hr/>
   <h3>
    Survival Analysis
   </h3>
   <p>
    <ul>
     <li>
      to estimate risk; how likely an event is to occur
     </li>
     <li>
      Survival analysis is estimating the length of time until an event occurs.
     </li>
     <li>
      If our data are complete and unbiased, standard regression methods may work.
     </li>
     <li>
      Survival Analysis allows us to consider cases with incomplete or censored data.
     </li>
     <li>
      Survival function measures the probability that a subject will survive past time t.
      <br/>
      <mark>
       S(t) = P(T&gt;t)
      </mark>
      where T is the time of event.
     </li>
     <li>
      The function S(t) is non-increasing, and starts at 1.
     </li>
     <li>
      For high enough t, the value of S(t) is 0 and this is where S(t) ends.
     </li>
     <li>
      <mark>
       Hazard Rate
      </mark>
      is the instantaneous rate at which events occur, i.e.
      <br/>
      <mark>
       h(t) = f(t)/S(t)
      </mark>
      . Sum of all the Hazard rates until a point of time t gives the 
            cumulative hazard rate.
      <b>
       This represents accumulated risk over time
      </b>
      .
     </li>
     <li>
      <mark>
       Kaplan-Meier plot
      </mark>
      can be used as a non-parametric estimator for survival probability.
      <ul>
       <li>
        It plots the cumulative probability of survival beyond each point of time.
       </li>
      </ul>
     </li>
     <li>
      To use the Kaplan-Meier curve for our analysis. It gives sample averages.
      <p class="code-text">
       from lifelines import KaplanMeierFitter

model = KaplanMeierFitter()
#here, month and churn are two pd series; for example month and churn values of customers etc
model.fit(month, churn)
model.plot()
      </p>
     </li>
     <li>
      <mark>
       Survival Regression
      </mark>
      <ul>
       <li>
        KM curve gives sample averages; but we may want to use individual level data for survival rate prediction.
       </li>
       <li>
        survival regression allows us to generate estimates of total risk as a function of time
       </li>
       <li>
        makes use of censored and uncensored observations to predict hazard rates
       </li>
       <li>
        allow us to estimate feature effects
       </li>
      </ul>
     </li>
     <li>
      TODO: CPH model
      <ul>
       <li>
        a tool for survival model.
       </li>
       <li>
        it assumes features have a constant proportional impact on the hazard rate.
       </li>
       <li>
        using CPH, we can plot estimated survival curves for various categories.
       </li>
      </ul>
     </li>
    </ul>
   </p>
  </div>
 </body>
</html>
